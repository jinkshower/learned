## 힙(Heap)의 구현
* 힙을 저장하는 표준적인 자료구조는 배열입니다.
* 구현을 쉽게 하기 위해 배열의 첫번째 인덱스인 0은 사용되지 않고 1번부터 사용됩니다.
* 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않습니다. 예를 들어, 루트 노드는 항상 배열의 1번 인덱스이고 루트 노드의 왼쪽 자식은 2번 인덱스, 오른쪽 자식은 3번 인덱스입니다. 힙에 삽입과 삭제가 일어나도 변경되지 않습니다.
* 부모 노드와 자식 노드의 관계
    * 부모 노드 인덱스 번호 = 자식 노드 인덱스 번호 / 2
    * 왼쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2
    * 오른쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2 + 1

## 힙(Heap)의 동작

### 힙(Heap)에 데이터 삽입하기

1. 위에서 말씀드린대로 힙은 완전 이진 트리이므로, 데이터가 삽입되면 왼쪽 최하단부 노드부터 채워집니다.
2. 새로운 노드와 부모 노드의 key 값을 비교해 교환합니다.

### 힙(Heap)에서 데이터 삭제하기

* 힙은 최대값 또는 최소값을 최상단(루트) 노드에 두고 꺼내 쓰기 위해 만들어졌기 때문에, 보통 최상단(루트) 노드를 삭제합니다.
* 최상단의 데이터 삭제 시, 힙의 마지막 노드를 최상단(루트) 노드로 이동합니다.
* 루트 노드의 값이 자식 노드보다 작을 경우, 루트 노드의 자식 노드 중 가장 큰 값을 가진 노드와 위치를 바꿔줍니다.
* 위 작업을 반복해줍니다.

MaxHeap 구현 코드

```java
public class MaxHeap {

    int[] heap;
    int size;

    public MaxHeap(int capacity) {
        //heap 배열은 1부터 시작한다.
        //부모가 n이면 왼쪽 자식은 2n, 오른쪽 자식은 2n+1이다.
        heap = new int[capacity + 1];
        size = 0;
    }

    public void insert(int value) {
        //힙 가장 마지막에 value를 넣는다.
        heap[++size] = value;
        // 해당 노드의 부모와 비교하여 부모가 작으면 swap
        // 부모와 비교하므로 i를 2로 나눈다.
        for (int i = size; i > 1; i /= 2) {

            if (heap[i / 2] < heap[i]) {
                swap(i / 2, i);
            } else {
                break;
            }
        }
    }

    public int poll() {
        if (size == 0) {
            return 0;
        }
        // 힙의 마지막 노드를 최상단으로 이동한다
        int item = heap[1];//루트 노드값을 일단 저장
        heap[1] = heap[size]; //마지막 노드를 최상단으로 이동한다.
        heap[size--] = 0; //사이즈를 하나 줄이고 마지막 노드 0 초기화

        // 루트 이동 후 자식 2개를 비교해 더 큰 값과 swap한다.
        for (int i = 1; i * 2 <= size; ) {
            //마지막 노드가 왼쪽 노드와 오른쪽 노드 보다 크면 끝
            if (heap[i] > heap[i * 2] && heap[i] > heap[i * 2 + 1]) {
                break;
            }

            //왼쪽 노드가 더 큰 경우, swap
            else if (heap[i * 2] > heap[i * 2 + 1]) {
                swap(i, i * 2);
                i = i * 2;
            } else {
                swap(i, i * 2 + 1);
                i = i * 2 + 1;
            }
        }

        return item; //최상단 노드값을 반환한다.
    }

    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
```
