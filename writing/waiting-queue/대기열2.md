## 수강신청 대기열을 구현하라


![Pasted image 20240822173017](https://github.com/user-attachments/assets/0c13153f-3bb7-40d2-ab38-8e67005fa1c0)

![Pasted image 20240822172407](https://github.com/user-attachments/assets/c328a808-bb8b-41eb-afb5-359c14546830)

사용자의 트래픽이 많이 몰릴 것으로 예상되는 지점을 어떻게 해결하여 애플리케이션을 방어할까?

1. 메인페이지는 변경될 사항이 없으므로 각 애플리케이션의 local cache를 사용하여 빠른 응답을 준다.
2. 각 애플리케이션에서 localCounter를 증가한 값을 사용자에게 응답한다.
3. 전역으로 counter 관리가 필요하니 각 애플리케이션이 2~3초 마다 자기가 가진 counter값을 DB의 global counter에 반영하고 자신의 local counter도 업데이트 한다. 이 때 이 요청은 락을 사용하여 일관성을 맞춘다.
4. 사용자가 순위를 지속적으로 물어본다. 애플리케이션에서는 해당 번호를 그냥 1000정도(예시) 낮게 하여 응답한다.
5. 만약 사용자의 순위가 1000보다 낮은 요청이 온다면 수강신청 로직을 시행한다. 수강신청 로직을 시행한다면 localCounter 값을 낮추면 될 것이다.

DB 호출 + 락을 사용하는 로직은 일정 주기 * 애플리케이션의 수밖에 없으므로 크게 성능저하가 우려되지는 않는다. localCounter를 업데이트 하는 부분은 애플리케이션의 개수만큼 나누어 지고 ram을 통한 접근이므로 성능상 문제가 되지 않을 것으로 예상된다.


사용자의 rank를 받아 0이상의 1000을 뺀 값을 응답.
```java
@PostMapping("/my-rank")  
public ResponseEntity<String> refreshRank(@RequestParam long rank) {  
    // 1. 순위를 1000 정도 깎음  
    long newRank = Math.max(rank - 1000, 0);  
  
    // 2. 응답으로 조정된 순위 반환  
    return ResponseEntity.ok("new rank: " + newRank);  
}
```

로컬 카운터와 db에서 읽어온 글로벌 카운터를 매칭하는 메서드
```java  
@Transactional  
public void refreshGlobalCounter() {  
    // 1. 비관적 락으로 전역 카운터 가져오기  
    Long currentGlobalCounter = jdbcTemplate.queryForObject(  
       "SELECT counter FROM global_counter WHERE id = 1 FOR UPDATE",  
       Long.class  
    );  
  
    // 2. 로컬 카운터 값 더하기  
    long newGlobalCounter = currentGlobalCounter + localCounter.get();  
  
    // 3. 새로운 카운터 값을 DB에 업데이트  
    jdbcTemplate.update(  
       "UPDATE global_counter SET counter = ? WHERE id = 1",  
       newGlobalCounter  
    );  
	// 4. 로컬 카운터 업데이트 하기
    localCounter.set(newGlobalCounter);  
}
```
