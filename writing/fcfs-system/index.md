# 선착순 시스템 설계

## 요구사항

e-commerce 시스템을 디자인한다.

`요구사항`

1. 아이폰 출시 이벤트가 진행되는데 물량이 1000개.
2. 12시에 오픈하여 선착순 1000명에게만 살수 있게 한다.
3. 예상 이벤트참가 인원은 수십만명이다.
4. 안전하게 이벤트를 진행할 시스템을 디자인하라.

### 가정

- 평소 트래픽

요구사항에서 먼저 주목한 점은 예상 이벤트 참가 인원이 수십만명이라는 점이다.  블랙프라이데이 세일이나 배민의 선착순 이벤트에서 it기업들은 평소의 트래픽보다 50 ~ 100배의 증가를 보였다고 한다.

이를 통해 우리는 해당 이커머스에 이벤트가 없는 평소 트래픽은 5~ 6천 RPM(Request Per Minute), 즉 90 ~100RPS(Request Per Second) 정도. 즉, 성공한 이커머스 사이트라고 가정할 것이다.

- 결제

선착순 1000명에게만 살수 있게 한다를 선착순으로 결제를 완료한 1000명으로 구체화할 것이다. 이미 대다수 티켓팅 서비스, 선착순 이벤트(배민 치킨 할인)등이 이렇게 진행된다.

대개는 PG사와의 연동으로 결제를 처리하고 결제 완료를 응답받는 식으로 결제를 처리하는 이커머스가 대부분이다. 결제는 외부 API 요청(카드사에 직접 요청하거나 pg사에 요청하거나)을 통해 결제가 완료 된다고 가정한다.

- 비용

비용은 무제한이지만 할 수 있다면 최적화하면 좋다.

## 주의해야 할 것

- 기존 서버의 기존 요청도 처리되어야 한다.

- 선착순 1000명을 지키는 안전성을 처리량, 지연시간보다 우선한다.

- 선착순 주문의 완료, 즉 재고를 감소 시키는 flow는 어떻게 되나?

장바구니 추가 -> 장바구니에서 주문클릭 -> 결제 진행 -> 결제 완료 -> 재고 감소.

## Version 0 기본적인 웹사이트

![Pasted image 20240731082044](https://github.com/user-attachments/assets/8e291de0-b77e-48f4-93b5-a7fb83c3967f)

WAS, DBMS로 구성되어 있다. WAS는 무엇을 써도 상관없지만 DB는 RDBMS를 골랐다. 주문 과정에서 재고의 즉각적인 일관성이 중요할 것이므로 RDB의 ACID를 이용하기 위해서다. 해당 시스템에서 선착순 이벤트를 한다면, 안정성을 위해 재고에 DB락을 걸게 될 것이다.

- 선착순 이벤트 시작!

우리의 이커머스는 Version0에서 선착순 이벤트에 실패했다. 수십만명이 하나의 재고를 업데이트하기 위해 접속했고 메인페이지를 보던 사용자들도 DB커넥션풀이 모두 락을 대기하고 있어 메인페이지를 보는 읽기 쿼리조차 날릴수 없었기 때문이다ㅜㅜ

- 문제점

트래픽이 증가할 시 WAS,DB에 모두 병목현상이 생길 수 있다.

WAS가 하나면 배포 과정(서버 다운 -> 서버 업)에서 실제 웹 사이트는 다운되어야 한다.

모든 요청을 WAS에서 DB 호출로 처리한다.

## Version 1 다중화와 캐싱

그래서 경영진은 돈을 좀 쓰기로 한다!

![Pasted image 20240731084304](https://github.com/user-attachments/assets/f0051831-a141-4c85-8cbd-202d176a34fc)

WAS를 무상태로 만들어 Scale-out를 한다. 늘어나는 트래픽에 대비해 auto-scale이 되게 하였고, 하나의 DB에 모든 읽기,쓰기 요청이 몰리지 않게 DB 복제, 마스터 DB샤딩을 통해 쿼리를 분산시킨다.

was가 여러개가 되었기 때문에 유저 세션 유지를 위해 공통의 SessionDB가 따로 필요하다. 여러개의 was에 고르게 트래픽을 분산하기 위해 Load Balancer가 도입되었다.

이커머스에서 가장 많은 쿼리가 예상되는 읽기에 DB층의 부담을 줄이기 위해 Cache를 도입했고 큰 이미지들은 binary를 직접 저장하지 않고 S3와 같은 image db를 사용하여 db에 적재되는 데이터량을 줄이기로 했다.

또한 CDN을 도입하여 많은 읽기 쿼리를 웹서버 계층으로 오지 않게 하였다. 그리고 저번 선착순 이벤트를 실패한 이유를 도통 알 수가 없어서 monitoring 시스템을 도입하여 로그와 메트릭을 분석하기로 한다.

해당 시스템에서 재고의 동시성을 보장하기 위해 여전히 DB락을 쓰거나 분산락 도입을 고려할 수 있다.

- 선착순 이벤트 시작!

우리의 이커머스는 Version1에서 선착순 이벤트에는 많은 문제점이 생겼다. 수십만의 트래픽이 오자 짧은 시간동안 웹 사이트에 마비가 온 것이다. 이벤트에 참여하지 않고 과자나 사려했던 다른 유저들의 원성이 빗발쳤다.

선착순을 뚫고 아이폰을 결제하려한 유저들은 PG사의 서버 폭발로 결제에 실패해버렸다. 3~4시 쯤 다시 시도한 유저는 저는 되는데요? 글을 올려 이벤트 참가자들의 속을 긁었다. 서버 관리좀 똑바로 하라고 고객센터에 전화가 수천통이 왔다..

- 문제점

우리의 이커머스는 90~100의 RPS를 소화할 수 있는 환경을 구축했다. 하지만 50~100배의 트래픽 증가를 서버 증설로 버티려고 했다. auto-scale로 서버가 증설되었지만 그동안 수십만의 트래픽은 모든 WAS를 점령했고 부하를 분산해서 받을 수 있는 시점에 트래픽이 모두 PG사로 넘어갔고 이벤트는 끝나버렸다.

외부 API호출을 고려하지 않았다. PG사가 폭발될 가능성을 고려하지 않아서 결제 요청을 했음에도 PG사때문에 실패한 요청들이 저장되지 않았기 때문이다.

## 논의와 합의

개발자들은 깊은 고뇌에 빠졌다. 연달은 이벤트 실패에도 불구하고 경영진이 또! 선착순 이벤트를 하겠다고 나선 것이다. 이번에는 전사가 모여서 해당 이벤트를 성공시킬 회의를 열게 되었다.

1. 장바구니에서 결제를 요청한다면 재고를 감소시킨다.
2.  결제 요청을 정보로 남겨 이후에라도 처리한다.
3. 수십만의 트래픽을 동시에 처리하려 하지 않는다.

라는 합의사항이 도출되었다. 각각의 이유는 다음과 같다.

- 장바구니에서 결제를 요청한다면 재고를 감소시킨다.

이전의 로직은 결제가 완료되면 재고를 차감시키는 방식이었다. 하지만 PG사 연동으로 해당 요청은 실패할 수도 성공할수도 있는 요청이다. 또한 결제 중 다른 요청이 성공하여 재고가 남지 않게 되었다면 결제는 성공하지만 고객에게 줄 재고가 남지 않을 수도 있다.

따라서 결제 요청, 재고 감소를 하나의 트랜잭션으로 묶고 이후 결제가 잔고 부족, 변심 등의 이유로 실패한다면 보상 트랜잭션을 발행하는 방식을 사용한다.

- 결제 요청을 정보로 남겨 이후에라도 처리한다.

기획자들과의 논의를 통해 선착순의 의미를 명확히 했다. 장바구니에 추가하고 결제 버튼을 누른 사람을 우선한다. 따라서 이후에 이벤트에 장애가 생겨도 결제 요청까지만 했다면 적절한 CS처리로 대응할 수 있다.

- 수십만의 트래픽을 동시에 , 언제나 처리하려 하지 않는다.

트래픽이 치솟는 시점은 이벤트 시간으로 고정되어 있고 자주 일어나지 않는다. 따라서 해당 이벤트를 위한 시스템을 따로 구축, 연결하여 이벤트 시점에만 사용하면 비용적으로 절감될 수 있을 것이다.

## Version2 분리

![Pasted image 20240731113640](https://github.com/user-attachments/assets/77a04a97-71df-448f-8aa4-aeebd0d6d2aa)

상품과 결제를 다른 서비스로 나누고 장바구니 추가- 결제 요청까지를 하나의 이벤트로 보고 해당 이벤트를 저장한다. 이 때 이벤트 소싱으로 해당 이벤트를 저장하거나 메시지의 전송을 보장하는 브로커등을 사용한다. 해당 이벤트의 정보가 남아있다면 이후 결제가 실패해도 재처리를 하는데 사용될 수 있을 것이다.

이전에는 재고가 충분한지 판별 -결제 요청- 결제 성공- 재고 감소가 하나의 트랜잭션으로 구성되어 있었기에 재고에 대한 락이 (엄청나게) 길어질 수도 있는 가능성이 있었다. 이는 결국 다른 요청의 락대기를 길게할 수 밖에 없고 쓰레드풀 점유율이 높아져 결국 병목을 일으키게 되었다. 요청시 재고를 감소하고 외부 api 처리는 비동기로 바꿔 좀 더 많은 요청을 처리할 수 있게 한다.

![Pasted image 20240731114549](https://github.com/user-attachments/assets/c3273026-e239-436e-8ae7-ff3fd2ceee59)

선착순 이벤트를 위한 대기열을 구현한다. Load Balancer에서 이벤트에 참여하는 요청이라면 대기열로 보내고 아니라면 원래 상품 api를 사용하게 한다. 대기열에서 일정 수준의 트래픽만 처리하는 로직을 구현한다면 서버가 처리할 수 있는 만큼만 트래픽을 조정할 수 있을 것이다.(auto-scale이 끝난다면 더 받는 등)

선착순 이벤트 품목을 위한 Atomic DB를 따로 둔다.  재고의 일관성을 지키기 위해  Replicaion Read DB에서 읽어 온 재고값을 사용하는 것은 리스크가 있다. Write DB의 최신 결과값이 언제 반영될지 장담할 수 없기 때문이다.

따라서 Write DB에서 읽기 값을 가져오고 재고 감소의 쓰기를 해야 하는데 기존 서비스를 이용하는 요청과 같은 DB커넥션풀 사용한다면 기존 서비스 요청은 밀릴 수 밖에 없을 것이다. (90~100 RPS를 이벤트 중에도 처리한다 가정). 따라서 아이폰 재고의 즉각적 일관성을 지키는 Atomic DB를 행사 기간에만 따로 두어 처리한다면 기존 서비스 트래픽에 부하가 전파되지 않을 것이다.

- 문제점

Waiting Queue의 병목 현상이 문제가 될 수 있다. 수십만의 트래픽이 이 쪽으로 단기간에 들어오기 때문이다.

## 선착순 이벤트는 성공할까?

아무도 모른다. 사실 Version0, Version1에서 우리의 이커머스는 이벤트에 성공했을 수도 있다. 모든 건 가정일 뿐이기 때문이다..
